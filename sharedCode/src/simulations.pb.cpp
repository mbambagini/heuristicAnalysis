// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "simulations.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Simulations {

namespace {

const ::google::protobuf::Descriptor* Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* Result_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Result_reflection_ = NULL;
const ::google::protobuf::Descriptor* Simulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Simulation_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_simulations_2eproto() {
  protobuf_AddDesc_simulations_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "simulations.proto");
  GOOGLE_CHECK(file != NULL);
  Task_descriptor_ = file->message_type(0);
  static const int Task_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, period_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, deadline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, wcet_),
  };
  Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Task_descriptor_,
      Task::default_instance_,
      Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Task));
  Result_descriptor_ = file->message_type(1);
  static const int Result_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, activetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, sleeptime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, switchingtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, idletime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, nofpreemptions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, nofinvocations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, nofsleeps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, off_),
  };
  Result_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Result_descriptor_,
      Result::default_instance_,
      Result_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Result));
  Simulation_descriptor_ = file->message_type(2);
  static const int Simulation_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, tasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, utilization_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, core_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, bet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, feasible_),
  };
  Simulation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Simulation_descriptor_,
      Simulation::default_instance_,
      Simulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Simulation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Simulation));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_simulations_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Task_descriptor_, &Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Result_descriptor_, &Result::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Simulation_descriptor_, &Simulation::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_simulations_2eproto() {
  delete Task::default_instance_;
  delete Task_reflection_;
  delete Result::default_instance_;
  delete Result_reflection_;
  delete Simulation::default_instance_;
  delete Simulation_reflection_;
}

void protobuf_AddDesc_simulations_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021simulations.proto\022\013Simulations\"B\n\004Task"
    "\022\n\n\002id\030\001 \002(\005\022\016\n\006period\030\002 \002(\005\022\020\n\010deadline"
    "\030\003 \002(\005\022\014\n\004wcet\030\004 \002(\005\"\250\001\n\006Result\022\022\n\nactiv"
    "eTime\030\001 \002(\002\022\021\n\tsleepTime\030\002 \002(\002\022\025\n\rswitch"
    "ingTime\030\003 \002(\002\022\020\n\010idleTime\030\004 \002(\002\022\026\n\016nOfPr"
    "eemptions\030\005 \002(\005\022\026\n\016nOfInvocations\030\006 \002(\005\022"
    "\021\n\tnOfSleeps\030\007 \002(\005\022\013\n\003off\030\010 \002(\010\"\222\001\n\nSimu"
    "lation\022 \n\005tasks\030\001 \003(\0132\021.Simulations.Task"
    "\022\023\n\013utilization\030\002 \002(\002\022\014\n\004core\030\003 \002(\005\022\013\n\003b"
    "et\030\004 \002(\005\022 \n\003res\030\005 \001(\0132\023.Simulations.Resu"
    "lt\022\020\n\010feasible\030\006 \002(\010", 420);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "simulations.proto", &protobuf_RegisterTypes);
  Task::default_instance_ = new Task();
  Result::default_instance_ = new Result();
  Simulation::default_instance_ = new Simulation();
  Task::default_instance_->InitAsDefaultInstance();
  Result::default_instance_->InitAsDefaultInstance();
  Simulation::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_simulations_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_simulations_2eproto {
  StaticDescriptorInitializer_simulations_2eproto() {
    protobuf_AddDesc_simulations_2eproto();
  }
} static_descriptor_initializer_simulations_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Task::kIdFieldNumber;
const int Task::kPeriodFieldNumber;
const int Task::kDeadlineFieldNumber;
const int Task::kWcetFieldNumber;
#endif  // !_MSC_VER

Task::Task()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Task::InitAsDefaultInstance() {
}

Task::Task(const Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Task::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  period_ = 0;
  deadline_ = 0;
  wcet_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Task::~Task() {
  SharedDtor();
}

void Task::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Task_descriptor_;
}

const Task& Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_simulations_2eproto();  return *default_instance_;
}

Task* Task::default_instance_ = NULL;

Task* Task::New() const {
  return new Task;
}

void Task::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    period_ = 0;
    deadline_ = 0;
    wcet_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_period;
        break;
      }
      
      // required int32 period = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_period:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &period_)));
          set_has_period();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_deadline;
        break;
      }
      
      // required int32 deadline = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deadline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deadline_)));
          set_has_deadline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_wcet;
        break;
      }
      
      // required int32 wcet = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wcet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wcet_)));
          set_has_wcet();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 period = 2;
  if (has_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->period(), output);
  }
  
  // required int32 deadline = 3;
  if (has_deadline()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->deadline(), output);
  }
  
  // required int32 wcet = 4;
  if (has_wcet()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->wcet(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 period = 2;
  if (has_period()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->period(), target);
  }
  
  // required int32 deadline = 3;
  if (has_deadline()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->deadline(), target);
  }
  
  // required int32 wcet = 4;
  if (has_wcet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->wcet(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Task::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 period = 2;
    if (has_period()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->period());
    }
    
    // required int32 deadline = 3;
    if (has_deadline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deadline());
    }
    
    // required int32 wcet = 4;
    if (has_wcet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wcet());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Task::MergeFrom(const Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_period()) {
      set_period(from.period());
    }
    if (from.has_deadline()) {
      set_deadline(from.deadline());
    }
    if (from.has_wcet()) {
      set_wcet(from.wcet());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Task::CopyFrom(const Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void Task::Swap(Task* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(period_, other->period_);
    std::swap(deadline_, other->deadline_);
    std::swap(wcet_, other->wcet_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Task_descriptor_;
  metadata.reflection = Task_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Result::kActiveTimeFieldNumber;
const int Result::kSleepTimeFieldNumber;
const int Result::kSwitchingTimeFieldNumber;
const int Result::kIdleTimeFieldNumber;
const int Result::kNOfPreemptionsFieldNumber;
const int Result::kNOfInvocationsFieldNumber;
const int Result::kNOfSleepsFieldNumber;
const int Result::kOffFieldNumber;
#endif  // !_MSC_VER

Result::Result()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Result::InitAsDefaultInstance() {
}

Result::Result(const Result& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Result::SharedCtor() {
  _cached_size_ = 0;
  activetime_ = 0;
  sleeptime_ = 0;
  switchingtime_ = 0;
  idletime_ = 0;
  nofpreemptions_ = 0;
  nofinvocations_ = 0;
  nofsleeps_ = 0;
  off_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Result::~Result() {
  SharedDtor();
}

void Result::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Result::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Result_descriptor_;
}

const Result& Result::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_simulations_2eproto();  return *default_instance_;
}

Result* Result::default_instance_ = NULL;

Result* Result::New() const {
  return new Result;
}

void Result::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    activetime_ = 0;
    sleeptime_ = 0;
    switchingtime_ = 0;
    idletime_ = 0;
    nofpreemptions_ = 0;
    nofinvocations_ = 0;
    nofsleeps_ = 0;
    off_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float activeTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &activetime_)));
          set_has_activetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_sleepTime;
        break;
      }
      
      // required float sleepTime = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sleepTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sleeptime_)));
          set_has_sleeptime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_switchingTime;
        break;
      }
      
      // required float switchingTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_switchingTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &switchingtime_)));
          set_has_switchingtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_idleTime;
        break;
      }
      
      // required float idleTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_idleTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &idletime_)));
          set_has_idletime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_nOfPreemptions;
        break;
      }
      
      // required int32 nOfPreemptions = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nOfPreemptions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nofpreemptions_)));
          set_has_nofpreemptions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_nOfInvocations;
        break;
      }
      
      // required int32 nOfInvocations = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nOfInvocations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nofinvocations_)));
          set_has_nofinvocations();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_nOfSleeps;
        break;
      }
      
      // required int32 nOfSleeps = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nOfSleeps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nofsleeps_)));
          set_has_nofsleeps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_off;
        break;
      }
      
      // required bool off = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_off:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &off_)));
          set_has_off();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float activeTime = 1;
  if (has_activetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->activetime(), output);
  }
  
  // required float sleepTime = 2;
  if (has_sleeptime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->sleeptime(), output);
  }
  
  // required float switchingTime = 3;
  if (has_switchingtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->switchingtime(), output);
  }
  
  // required float idleTime = 4;
  if (has_idletime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->idletime(), output);
  }
  
  // required int32 nOfPreemptions = 5;
  if (has_nofpreemptions()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->nofpreemptions(), output);
  }
  
  // required int32 nOfInvocations = 6;
  if (has_nofinvocations()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->nofinvocations(), output);
  }
  
  // required int32 nOfSleeps = 7;
  if (has_nofsleeps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->nofsleeps(), output);
  }
  
  // required bool off = 8;
  if (has_off()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->off(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Result::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float activeTime = 1;
  if (has_activetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->activetime(), target);
  }
  
  // required float sleepTime = 2;
  if (has_sleeptime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->sleeptime(), target);
  }
  
  // required float switchingTime = 3;
  if (has_switchingtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->switchingtime(), target);
  }
  
  // required float idleTime = 4;
  if (has_idletime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->idletime(), target);
  }
  
  // required int32 nOfPreemptions = 5;
  if (has_nofpreemptions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->nofpreemptions(), target);
  }
  
  // required int32 nOfInvocations = 6;
  if (has_nofinvocations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->nofinvocations(), target);
  }
  
  // required int32 nOfSleeps = 7;
  if (has_nofsleeps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->nofsleeps(), target);
  }
  
  // required bool off = 8;
  if (has_off()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->off(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Result::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float activeTime = 1;
    if (has_activetime()) {
      total_size += 1 + 4;
    }
    
    // required float sleepTime = 2;
    if (has_sleeptime()) {
      total_size += 1 + 4;
    }
    
    // required float switchingTime = 3;
    if (has_switchingtime()) {
      total_size += 1 + 4;
    }
    
    // required float idleTime = 4;
    if (has_idletime()) {
      total_size += 1 + 4;
    }
    
    // required int32 nOfPreemptions = 5;
    if (has_nofpreemptions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nofpreemptions());
    }
    
    // required int32 nOfInvocations = 6;
    if (has_nofinvocations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nofinvocations());
    }
    
    // required int32 nOfSleeps = 7;
    if (has_nofsleeps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nofsleeps());
    }
    
    // required bool off = 8;
    if (has_off()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Result::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Result* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Result*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Result::MergeFrom(const Result& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_activetime()) {
      set_activetime(from.activetime());
    }
    if (from.has_sleeptime()) {
      set_sleeptime(from.sleeptime());
    }
    if (from.has_switchingtime()) {
      set_switchingtime(from.switchingtime());
    }
    if (from.has_idletime()) {
      set_idletime(from.idletime());
    }
    if (from.has_nofpreemptions()) {
      set_nofpreemptions(from.nofpreemptions());
    }
    if (from.has_nofinvocations()) {
      set_nofinvocations(from.nofinvocations());
    }
    if (from.has_nofsleeps()) {
      set_nofsleeps(from.nofsleeps());
    }
    if (from.has_off()) {
      set_off(from.off());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Result::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Result::CopyFrom(const Result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Result::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;
  
  return true;
}

void Result::Swap(Result* other) {
  if (other != this) {
    std::swap(activetime_, other->activetime_);
    std::swap(sleeptime_, other->sleeptime_);
    std::swap(switchingtime_, other->switchingtime_);
    std::swap(idletime_, other->idletime_);
    std::swap(nofpreemptions_, other->nofpreemptions_);
    std::swap(nofinvocations_, other->nofinvocations_);
    std::swap(nofsleeps_, other->nofsleeps_);
    std::swap(off_, other->off_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Result::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Result_descriptor_;
  metadata.reflection = Result_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Simulation::kTasksFieldNumber;
const int Simulation::kUtilizationFieldNumber;
const int Simulation::kCoreFieldNumber;
const int Simulation::kBetFieldNumber;
const int Simulation::kResFieldNumber;
const int Simulation::kFeasibleFieldNumber;
#endif  // !_MSC_VER

Simulation::Simulation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Simulation::InitAsDefaultInstance() {
  res_ = const_cast< ::Simulations::Result*>(&::Simulations::Result::default_instance());
}

Simulation::Simulation(const Simulation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Simulation::SharedCtor() {
  _cached_size_ = 0;
  utilization_ = 0;
  core_ = 0;
  bet_ = 0;
  res_ = NULL;
  feasible_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Simulation::~Simulation() {
  SharedDtor();
}

void Simulation::SharedDtor() {
  if (this != default_instance_) {
    delete res_;
  }
}

void Simulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Simulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Simulation_descriptor_;
}

const Simulation& Simulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_simulations_2eproto();  return *default_instance_;
}

Simulation* Simulation::default_instance_ = NULL;

Simulation* Simulation::New() const {
  return new Simulation;
}

void Simulation::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    utilization_ = 0;
    core_ = 0;
    bet_ = 0;
    if (has_res()) {
      if (res_ != NULL) res_->::Simulations::Result::Clear();
    }
    feasible_ = false;
  }
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Simulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Simulations.Task tasks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_tasks;
        if (input->ExpectTag(21)) goto parse_utilization;
        break;
      }
      
      // required float utilization = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_utilization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &utilization_)));
          set_has_utilization();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_core;
        break;
      }
      
      // required int32 core = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_core:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &core_)));
          set_has_core();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_bet;
        break;
      }
      
      // required int32 bet = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bet_)));
          set_has_bet();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_res;
        break;
      }
      
      // optional .Simulations.Result res = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_res:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_res()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_feasible;
        break;
      }
      
      // required bool feasible = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_feasible:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &feasible_)));
          set_has_feasible();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Simulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Simulations.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tasks(i), output);
  }
  
  // required float utilization = 2;
  if (has_utilization()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->utilization(), output);
  }
  
  // required int32 core = 3;
  if (has_core()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->core(), output);
  }
  
  // required int32 bet = 4;
  if (has_bet()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->bet(), output);
  }
  
  // optional .Simulations.Result res = 5;
  if (has_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->res(), output);
  }
  
  // required bool feasible = 6;
  if (has_feasible()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->feasible(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Simulation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Simulations.Task tasks = 1;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tasks(i), target);
  }
  
  // required float utilization = 2;
  if (has_utilization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->utilization(), target);
  }
  
  // required int32 core = 3;
  if (has_core()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->core(), target);
  }
  
  // required int32 bet = 4;
  if (has_bet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->bet(), target);
  }
  
  // optional .Simulations.Result res = 5;
  if (has_res()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->res(), target);
  }
  
  // required bool feasible = 6;
  if (has_feasible()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->feasible(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Simulation::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required float utilization = 2;
    if (has_utilization()) {
      total_size += 1 + 4;
    }
    
    // required int32 core = 3;
    if (has_core()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->core());
    }
    
    // required int32 bet = 4;
    if (has_bet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bet());
    }
    
    // optional .Simulations.Result res = 5;
    if (has_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->res());
    }
    
    // required bool feasible = 6;
    if (has_feasible()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .Simulations.Task tasks = 1;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Simulation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Simulation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Simulation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Simulation::MergeFrom(const Simulation& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_utilization()) {
      set_utilization(from.utilization());
    }
    if (from.has_core()) {
      set_core(from.core());
    }
    if (from.has_bet()) {
      set_bet(from.bet());
    }
    if (from.has_res()) {
      mutable_res()->::Simulations::Result::MergeFrom(from.res());
    }
    if (from.has_feasible()) {
      set_feasible(from.feasible());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Simulation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Simulation::CopyFrom(const Simulation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Simulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002e) != 0x0000002e) return false;
  
  for (int i = 0; i < tasks_size(); i++) {
    if (!this->tasks(i).IsInitialized()) return false;
  }
  if (has_res()) {
    if (!this->res().IsInitialized()) return false;
  }
  return true;
}

void Simulation::Swap(Simulation* other) {
  if (other != this) {
    tasks_.Swap(&other->tasks_);
    std::swap(utilization_, other->utilization_);
    std::swap(core_, other->core_);
    std::swap(bet_, other->bet_);
    std::swap(res_, other->res_);
    std::swap(feasible_, other->feasible_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Simulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Simulation_descriptor_;
  metadata.reflection = Simulation_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Simulations

// @@protoc_insertion_point(global_scope)
