// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: problem.proto

#ifndef PROTOBUF_problem_2eproto__INCLUDED
#define PROTOBUF_problem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Problem {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_problem_2eproto();
void protobuf_AssignDesc_problem_2eproto();
void protobuf_ShutdownFile_problem_2eproto();

class Task;
class Software;
class ProcessorType;
class Hardware;

// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 wcet = 2;
  inline bool has_wcet() const;
  inline void clear_wcet();
  static const int kWcetFieldNumber = 2;
  inline ::google::protobuf::int32 wcet() const;
  inline void set_wcet(::google::protobuf::int32 value);
  
  // repeated int32 wcets = 3;
  inline int wcets_size() const;
  inline void clear_wcets();
  static const int kWcetsFieldNumber = 3;
  inline ::google::protobuf::int32 wcets(int index) const;
  inline void set_wcets(int index, ::google::protobuf::int32 value);
  inline void add_wcets(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wcets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wcets();
  
  // required int32 period = 4;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 4;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);
  
  // required int32 deadline = 5;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 5;
  inline ::google::protobuf::int32 deadline() const;
  inline void set_deadline(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Problem.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_wcet();
  inline void clear_has_wcet();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wcet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wcets_;
  ::google::protobuf::int32 period_;
  ::google::protobuf::int32 deadline_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_problem_2eproto();
  friend void protobuf_AssignDesc_problem_2eproto();
  friend void protobuf_ShutdownFile_problem_2eproto();
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Software : public ::google::protobuf::Message {
 public:
  Software();
  virtual ~Software();
  
  Software(const Software& from);
  
  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Software& default_instance();
  
  void Swap(Software* other);
  
  // implements Message ----------------------------------------------
  
  Software* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Problem.Task tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::Problem::Task& tasks(int index) const;
  inline ::Problem::Task* mutable_tasks(int index);
  inline ::Problem::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::Problem::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Problem::Task >*
      mutable_tasks();
  
  // required double U = 2;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 2;
  inline double u() const;
  inline void set_u(double value);
  
  // required int32 units = 3;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 3;
  inline ::google::protobuf::int32 units() const;
  inline void set_units(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Problem.Software)
 private:
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_units();
  inline void clear_has_units();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Problem::Task > tasks_;
  double u_;
  ::google::protobuf::int32 units_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_problem_2eproto();
  friend void protobuf_AssignDesc_problem_2eproto();
  friend void protobuf_ShutdownFile_problem_2eproto();
  
  void InitAsDefaultInstance();
  static Software* default_instance_;
};
// -------------------------------------------------------------------

class ProcessorType : public ::google::protobuf::Message {
 public:
  ProcessorType();
  virtual ~ProcessorType();
  
  ProcessorType(const ProcessorType& from);
  
  inline ProcessorType& operator=(const ProcessorType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorType& default_instance();
  
  void Swap(ProcessorType* other);
  
  // implements Message ----------------------------------------------
  
  ProcessorType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessorType& from);
  void MergeFrom(const ProcessorType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required double Pidle = 2;
  inline bool has_pidle() const;
  inline void clear_pidle();
  static const int kPidleFieldNumber = 2;
  inline double pidle() const;
  inline void set_pidle(double value);
  
  // required double Psleep = 3;
  inline bool has_psleep() const;
  inline void clear_psleep();
  static const int kPsleepFieldNumber = 3;
  inline double psleep() const;
  inline void set_psleep(double value);
  
  // required double Pactive = 4;
  inline bool has_pactive() const;
  inline void clear_pactive();
  static const int kPactiveFieldNumber = 4;
  inline double pactive() const;
  inline void set_pactive(double value);
  
  // required double Pswitching = 5;
  inline bool has_pswitching() const;
  inline void clear_pswitching();
  static const int kPswitchingFieldNumber = 5;
  inline double pswitching() const;
  inline void set_pswitching(double value);
  
  // required double bet = 6;
  inline bool has_bet() const;
  inline void clear_bet();
  static const int kBetFieldNumber = 6;
  inline double bet() const;
  inline void set_bet(double value);
  
  // repeated int32 speed = 7;
  inline int speed_size() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 7;
  inline ::google::protobuf::int32 speed(int index) const;
  inline void set_speed(int index, ::google::protobuf::int32 value);
  inline void add_speed(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      speed() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_speed();
  
  // @@protoc_insertion_point(class_scope:Problem.ProcessorType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pidle();
  inline void clear_has_pidle();
  inline void set_has_psleep();
  inline void clear_has_psleep();
  inline void set_has_pactive();
  inline void clear_has_pactive();
  inline void set_has_pswitching();
  inline void clear_has_pswitching();
  inline void set_has_bet();
  inline void clear_has_bet();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double pidle_;
  double psleep_;
  double pactive_;
  double pswitching_;
  double bet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > speed_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_problem_2eproto();
  friend void protobuf_AssignDesc_problem_2eproto();
  friend void protobuf_ShutdownFile_problem_2eproto();
  
  void InitAsDefaultInstance();
  static ProcessorType* default_instance_;
};
// -------------------------------------------------------------------

class Hardware : public ::google::protobuf::Message {
 public:
  Hardware();
  virtual ~Hardware();
  
  Hardware(const Hardware& from);
  
  inline Hardware& operator=(const Hardware& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hardware& default_instance();
  
  void Swap(Hardware* other);
  
  // implements Message ----------------------------------------------
  
  Hardware* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hardware& from);
  void MergeFrom(const Hardware& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Problem.ProcessorType types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline const ::Problem::ProcessorType& types(int index) const;
  inline ::Problem::ProcessorType* mutable_types(int index);
  inline ::Problem::ProcessorType* add_types();
  inline const ::google::protobuf::RepeatedPtrField< ::Problem::ProcessorType >&
      types() const;
  inline ::google::protobuf::RepeatedPtrField< ::Problem::ProcessorType >*
      mutable_types();
  
  // repeated int32 processors = 2;
  inline int processors_size() const;
  inline void clear_processors();
  static const int kProcessorsFieldNumber = 2;
  inline ::google::protobuf::int32 processors(int index) const;
  inline void set_processors(int index, ::google::protobuf::int32 value);
  inline void add_processors(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      processors() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_processors();
  
  // required int32 nOfResources = 3;
  inline bool has_nofresources() const;
  inline void clear_nofresources();
  static const int kNOfResourcesFieldNumber = 3;
  inline ::google::protobuf::int32 nofresources() const;
  inline void set_nofresources(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Problem.Hardware)
 private:
  inline void set_has_nofresources();
  inline void clear_has_nofresources();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Problem::ProcessorType > types_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > processors_;
  ::google::protobuf::int32 nofresources_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_problem_2eproto();
  friend void protobuf_AssignDesc_problem_2eproto();
  friend void protobuf_ShutdownFile_problem_2eproto();
  
  void InitAsDefaultInstance();
  static Hardware* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required int32 id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Task::id() const {
  return id_;
}
inline void Task::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 wcet = 2;
inline bool Task::has_wcet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_wcet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_wcet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_wcet() {
  wcet_ = 0;
  clear_has_wcet();
}
inline ::google::protobuf::int32 Task::wcet() const {
  return wcet_;
}
inline void Task::set_wcet(::google::protobuf::int32 value) {
  set_has_wcet();
  wcet_ = value;
}

// repeated int32 wcets = 3;
inline int Task::wcets_size() const {
  return wcets_.size();
}
inline void Task::clear_wcets() {
  wcets_.Clear();
}
inline ::google::protobuf::int32 Task::wcets(int index) const {
  return wcets_.Get(index);
}
inline void Task::set_wcets(int index, ::google::protobuf::int32 value) {
  wcets_.Set(index, value);
}
inline void Task::add_wcets(::google::protobuf::int32 value) {
  wcets_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Task::wcets() const {
  return wcets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Task::mutable_wcets() {
  return &wcets_;
}

// required int32 period = 4;
inline bool Task::has_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 Task::period() const {
  return period_;
}
inline void Task::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// required int32 deadline = 5;
inline bool Task::has_deadline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_deadline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_deadline() {
  deadline_ = 0;
  clear_has_deadline();
}
inline ::google::protobuf::int32 Task::deadline() const {
  return deadline_;
}
inline void Task::set_deadline(::google::protobuf::int32 value) {
  set_has_deadline();
  deadline_ = value;
}

// -------------------------------------------------------------------

// Software

// repeated .Problem.Task tasks = 1;
inline int Software::tasks_size() const {
  return tasks_.size();
}
inline void Software::clear_tasks() {
  tasks_.Clear();
}
inline const ::Problem::Task& Software::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::Problem::Task* Software::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::Problem::Task* Software::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Problem::Task >&
Software::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Problem::Task >*
Software::mutable_tasks() {
  return &tasks_;
}

// required double U = 2;
inline bool Software::has_u() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Software::set_has_u() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Software::clear_has_u() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Software::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline double Software::u() const {
  return u_;
}
inline void Software::set_u(double value) {
  set_has_u();
  u_ = value;
}

// required int32 units = 3;
inline bool Software::has_units() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Software::set_has_units() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Software::clear_has_units() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Software::clear_units() {
  units_ = 0;
  clear_has_units();
}
inline ::google::protobuf::int32 Software::units() const {
  return units_;
}
inline void Software::set_units(::google::protobuf::int32 value) {
  set_has_units();
  units_ = value;
}

// -------------------------------------------------------------------

// ProcessorType

// required int32 id = 1;
inline bool ProcessorType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorType::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ProcessorType::id() const {
  return id_;
}
inline void ProcessorType::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required double Pidle = 2;
inline bool ProcessorType::has_pidle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorType::set_has_pidle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorType::clear_has_pidle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorType::clear_pidle() {
  pidle_ = 0;
  clear_has_pidle();
}
inline double ProcessorType::pidle() const {
  return pidle_;
}
inline void ProcessorType::set_pidle(double value) {
  set_has_pidle();
  pidle_ = value;
}

// required double Psleep = 3;
inline bool ProcessorType::has_psleep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessorType::set_has_psleep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessorType::clear_has_psleep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessorType::clear_psleep() {
  psleep_ = 0;
  clear_has_psleep();
}
inline double ProcessorType::psleep() const {
  return psleep_;
}
inline void ProcessorType::set_psleep(double value) {
  set_has_psleep();
  psleep_ = value;
}

// required double Pactive = 4;
inline bool ProcessorType::has_pactive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessorType::set_has_pactive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessorType::clear_has_pactive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessorType::clear_pactive() {
  pactive_ = 0;
  clear_has_pactive();
}
inline double ProcessorType::pactive() const {
  return pactive_;
}
inline void ProcessorType::set_pactive(double value) {
  set_has_pactive();
  pactive_ = value;
}

// required double Pswitching = 5;
inline bool ProcessorType::has_pswitching() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessorType::set_has_pswitching() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessorType::clear_has_pswitching() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessorType::clear_pswitching() {
  pswitching_ = 0;
  clear_has_pswitching();
}
inline double ProcessorType::pswitching() const {
  return pswitching_;
}
inline void ProcessorType::set_pswitching(double value) {
  set_has_pswitching();
  pswitching_ = value;
}

// required double bet = 6;
inline bool ProcessorType::has_bet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProcessorType::set_has_bet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProcessorType::clear_has_bet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProcessorType::clear_bet() {
  bet_ = 0;
  clear_has_bet();
}
inline double ProcessorType::bet() const {
  return bet_;
}
inline void ProcessorType::set_bet(double value) {
  set_has_bet();
  bet_ = value;
}

// repeated int32 speed = 7;
inline int ProcessorType::speed_size() const {
  return speed_.size();
}
inline void ProcessorType::clear_speed() {
  speed_.Clear();
}
inline ::google::protobuf::int32 ProcessorType::speed(int index) const {
  return speed_.Get(index);
}
inline void ProcessorType::set_speed(int index, ::google::protobuf::int32 value) {
  speed_.Set(index, value);
}
inline void ProcessorType::add_speed(::google::protobuf::int32 value) {
  speed_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProcessorType::speed() const {
  return speed_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProcessorType::mutable_speed() {
  return &speed_;
}

// -------------------------------------------------------------------

// Hardware

// repeated .Problem.ProcessorType types = 1;
inline int Hardware::types_size() const {
  return types_.size();
}
inline void Hardware::clear_types() {
  types_.Clear();
}
inline const ::Problem::ProcessorType& Hardware::types(int index) const {
  return types_.Get(index);
}
inline ::Problem::ProcessorType* Hardware::mutable_types(int index) {
  return types_.Mutable(index);
}
inline ::Problem::ProcessorType* Hardware::add_types() {
  return types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Problem::ProcessorType >&
Hardware::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::Problem::ProcessorType >*
Hardware::mutable_types() {
  return &types_;
}

// repeated int32 processors = 2;
inline int Hardware::processors_size() const {
  return processors_.size();
}
inline void Hardware::clear_processors() {
  processors_.Clear();
}
inline ::google::protobuf::int32 Hardware::processors(int index) const {
  return processors_.Get(index);
}
inline void Hardware::set_processors(int index, ::google::protobuf::int32 value) {
  processors_.Set(index, value);
}
inline void Hardware::add_processors(::google::protobuf::int32 value) {
  processors_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Hardware::processors() const {
  return processors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Hardware::mutable_processors() {
  return &processors_;
}

// required int32 nOfResources = 3;
inline bool Hardware::has_nofresources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hardware::set_has_nofresources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hardware::clear_has_nofresources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hardware::clear_nofresources() {
  nofresources_ = 0;
  clear_has_nofresources();
}
inline ::google::protobuf::int32 Hardware::nofresources() const {
  return nofresources_;
}
inline void Hardware::set_nofresources(::google::protobuf::int32 value) {
  set_has_nofresources();
  nofresources_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Problem

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_problem_2eproto__INCLUDED
